class {

    function getAllBooks( string searchTerm = "", numeric genreId = 0 ) {

        if(searchTerm.len() != 0) {
            return queryExecute("SELECT * FROM books b
                    INNER JOIN publishers p
                    ON b.publisherId=p.id
                    WHERE b.title LIKE :searchTermLike
                    OR b.isbn13 LIKE :searchTerm
                    OR p.id = :searchTerm            
                    OR p.name LIKE :searchTermLike
                ",
            {
            searchTermLike : '%#arguments.searchTerm#%',
            searchTerm : '#arguments.searchTerm#'
            });

        } else if( genreId > 0){
            return queryExecute("SELECT * FROM books b
                INNER JOIN genresToBooks gtb ON b.isbn13 = gtb.isbn13
                INNER JOIN publishers p ON b.publisherId = p.id
                WHERE gtb.genreId = :genreId ",
                {
                   genreId : '#arguments.genreId#'
                }); 
        }

    }

    function getBookByISBN13( required string ISBN13){
        return queryExecute("SELECT * FROM books WHERE ISBN13=:ISBN13",{ISBN13:arguments.ISBN13});
    }

    function saveBook( required string ISBN13 = "",
        required string title = "", 
        string ISBN = "",
        numeric weight = 0,
        string binding = "", 
        numeric pages = 0,
        numeric publisherId = 0,
        string language = "",
        string description,
        string image) {

        queryExecute("
            INSERT into books (ISBN13, title, ISBN, weight, binding, pages, publisherId, language, description, image) 
            VALUES (:ISBN13,:title, :ISBN, :weight, :binding, :pages, :publisherId, :language, :description, :image) 
            ON DUPLICATE KEY UPDATE 
                ISBN13=:ISBN13,
                title=:title,
                ISBN=:ISBN,
                weight=:weight,
                binding=:binding,
                pages=:pages,
                publisherId=:publisherId,
                language=:language,
                description=:description,
                image=:image
        ",{
            ISBN13: arguments.ISBN13,
            title: arguments.title,
            ISBN: arguments.ISBN,
            weight: arguments.weight,
            binding: arguments.binding,
            pages: arguments.pages,
            publisherId: arguments.publisherId,
            language: arguments.language,
            description: arguments.description,
            image: arguments.image
        });

    }   
    
    function getAllPublishers() {
       
        return queryExecute("SELECT * FROM publishers");
    }

    function getAllGenres() {
        return queryExecute("SELECT * FROM genres");
    }

    function saveGenreToBook( required numeric genreId = 0,
        required string ISBN13 = "") {

        queryExecute("
            INSERT INTO genresToBooks (genreId, ISBN13) 
            VALUES (:genreId, :ISBN13) 
            ON DUPLICATE KEY UPDATE 
                genreId=:genreId,
                ISBN13=:ISBN13
        ",{
            genreId: arguments.genreId,
            ISBN13: arguments.ISBN13
        });

    }   

    function clearAllBookGenres( string ISBN13 = "") {
        return queryExecute("DELETE FROM genresToBooks WHERE ISBN13=:ISBN13",{ISBN13:arguments.ISBN13});
    }

    function getAllGenresForBook(genreId=0, ISBN13=''){
        var ourSQL = "SELECT * FROM books b 
            INNER JOIN genresToBooks gtb ON b.ISBN13 = gtb.ISBN13
            INNER JOIN genres g on gtb.genreId = g.genreId";
        if(arguments.genreId > 0){
           ourSQL = ourSQL & " WHERE gtb.genreId = #arguments.genreId#";
        }
        if(arguments.ISBN13.len() > 0){
           ourSQL = ourSQL & " WHERE gtb.ISBN13 = '#arguments.ISBN13#'";
        }

        return queryExecute(ourSQL);
    } 

    function distinctGenres(){
        return queryExecute("SELECT DISTINCT g.genreId, g.genreName FROM genresToBooks gtb 
             INNER JOIN genres g ON g.genreId = gtb.genreId ORDER BY g.genreName");
    }


    // DO NOT USE.
    // This code doesn't seem to be working correctly but I can't figure out why
    /*
        This is really close and I applaud the research you must have done in researching potential solutions. 
        The code for this is on  https://book.umlinfo2480.com/week-7-working-with-selects-files-wysiwyg-and-more./adding-images-to-our-store). This is here for reference.
         The uploadFile function takes 1 parameter which is the name of the input which has the image data. I've added it here. 
    */
    function uploadFile( fileField  ){
        /* When you started debugging, this was a good first attempt. Using 
        The request scope is all of the variables which are part of the overall request which is being processed by the server at this moment. 
        You can see it by using <bx:dump var="#request#" />. It doesn't have a "file" key which is why this is failing. 

        The file scope is all all the variables which are generated when working with a file. The data for our form is inside the FORM scope which is all
        the data submitted via the POST method in a request. 


        */
        //dump(var=request); abort;
        //var uploadedFile = request.file.uploadImage;  // Access file
        /*
        if ( !uploadedFile.isEmpty() ) {
            var savePath = expandPath( "/bookstore/common/images/" & uploadedFile.getName() );
            uploadedFile.write( savePath );
        }*/
        /* This is good messaging but the code in manageBooks.bxm is relying on returning the name of the image which was uploaded to put into the DB */
        //return {"File uploaded successfully!"};


        // This makes sense. Puttting something like the path to the images into a variable allows you to use it in multiple places should you need to.
        var uploadPath = expandPath( "/bookstore/common/images/" );

        // Perform file upload
        // This is good syntax and working code. Unfortunately, the request.file.uploadImage was preventing it from getting here. :(.
        // One comment is that not putting in an option like "makeUnique" (see below) means that if an image of the same name is uploaded it will throw an error.
        var result = fileUpload( uploadPath, "uploadImage","*","makeUnique" );
        //writedump(result);abort;

        //This technique makes sense. If the call doens't succeed, we want to let the user or the logging know it failed. However, even if it fails, 
        // the result variable, doesn't have a key called "success".
        //if ( !result.success ) {
        //    return { error: "File upload failed: " & result.error };
        //}

        //I replaced filePath here since that is the name of the key in "result" that contains the name of the file on the server.
        // Uncomment the //writeDump(result); abort line above to see what I mean
        return { success: true, filePath: result.serverFileName };        

        /* return fileUpload(expandPath("/bookstore/common/images/"), fileField,"*","makeUnique"); */

        // The original function from the docs. This might have been originally failing because there was no /bookstore/common/images folder (Step 1 under Handling The Uploaded Image)
        //return fileUpload(expandPath("/bookstore/common/images/"), "uploadImage","*","makeUnique"); 
     }
}